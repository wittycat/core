#### 存储引擎
* [MyISAM和InnoDB区别](https://blog.csdn.net/qq_35642036/article/details/82820178) 
#### mysql索引相关，为什么用B+树 ？
* hash ：能排序，按照范围返回
* 二叉树 ：太深，有回旋查找问题
* b树 ：变矮了，还有回旋查找问题
* b+树 ：变矮了，链表（排序的）解决了回旋查找问题。
#### char和varchar的区别
* char类型的长度是固定的，varchar的长度是可变的。
* char类型的效率比varchar的效率稍高。
* 底层存储方式不同，char的存储方式是：对英文字符（ASCII）占用一个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用两个字节，汉字也占用了两个字节。两者的存储数据都非Unicode的字符数据
#### mysql建索引的原则，索引是不是越多越好，为什么？
* 数据量小的表不需要建立索引,建立会增加额外的索引开销；数据变更需要维护索引,因此更多的索引意味着更多的维护成本；
* 一般建议在6个索引内，能适应联合索引何以合并下

#### 主键索引和唯一索引哪个效率高?
* 普通索引保存的都是主键的地址,然后再根据主键去查询,所以要检索两次,因此主键索引效率高于唯一索引
#### Mysql为什么对字段使用函数就不走索引了?还有什么情况不走索引
* 对索引的字段做函数操作,可能会破坏索引值的有序性因此优化器就决定放弃走树搜索的功能,需要注意的是,优化器并不是要放弃使用这个索引
* 隐式类型转换不走索引:比方说tradeid本来是varchar,结果写成了如下sql,没有带引号

    mysql> select * from tradelog where tradeid=110717;
* 不遵守最左前缀原则对复合索引的查询的操作
#### MySQL的delete和truncate的区别?
* delete是一条一条删除记录的,配合事件和回滚可以找回数据,并且自增不会重置
* truncate是直接删除整个表,然后创建一个一模一样的新表,auto_increment会被重置,且数据无法找回