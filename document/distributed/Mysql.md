#### 函数
#### 存储引擎（与锁）
 * MyISAM
   * 表锁
 * [InnoDB](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)
   * 表锁
   * 行锁：record-level lock
      * record lock  锁住某一行记录
      * gap lock     锁住某一段范围中的记录
      * next key lock 是前两者效果的叠加
      
            锁基于索引，锁的是索引，当没有索引时，如果进行写操作就会锁整个表
        
   * 页面锁（是否存在于InnoDB中？）
   
        表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
        行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
        页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
       
    * 意图锁 
#### mysql索引相关，为什么用B+树 
#### mysql常用的数据类型
#### char和varchar的区别
#### mysql建索引的原则，索引是不是越多越好，为什么
#### 主键索引和唯一索引哪个效率高?
* 普通索引保存的都是主键的地址,然后再根据主键去查询,所以要检索两次,因此主键索引效率高于唯一索引
#### Mysql为什么对字段使用函数就不走索引了?还有什么情况不走索引
* 对索引的字段做函数操作,可能会破坏索引值的有序性因此优化器就决定放弃走树搜索的功能,需要注意的是,优化器并不是要放弃使用这个索引
* 隐式类型转换不走索引:比方说tradeid本来是varchar,结果写成了如下sql,没有带引号

    mysql> select * from tradelog where tradeid=110717;
* 不遵守最左前缀原则对复合索引的查询的操作
#### MySQL的delete和truncate的区别?
* delete是一条一条删除记录的,配合事件和回滚可以找回数据,并且自增不会重置
* truncate是直接删除整个表,然后创建一个一模一样的新表,auto_increment会被重置,且数据无法找回