#### 存储引擎 MyISAM  InnoDB
* InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 
* InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
* InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
* InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）
* InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

#### mysql索引相关，为什么用B+树 ？
* hash ：不能排序，按照范围返回
* 二叉树 ：太深，有回旋查找问题
* b树 ：变矮了，还有回旋查找问题
* b+树 ：变矮了，链表（排序的）解决了回旋查找问题，按照范围返回

#### char和varchar的区别
* char类型的长度是固定的，varchar的长度是可变的。
* char类型的效率比varchar的效率稍高。
* 底层存储方式不同，char的存储方式是：对英文字符（ASCII）占用一个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用两个字节，汉字也占用了两个字节。两者的存储数据都非Unicode的字符数据

#### mysql建索引的原则，索引是不是越多越好，为什么？
* 数据量小的表不需要建立索引,建立会增加额外的索引开销；数据变更需要维护索引,因此更多的索引意味着更多的维护成本；
* 一般建议在6个索引内，能适应联合索引何以合并下

#### 主键索引和唯一索引哪个效率高?
* 普通索引保存的都是主键的地址,然后再根据主键去查询,所以要检索两次,因此主键索引效率高于唯一索引

#### Mysql为什么对字段使用函数就不走索引了?还有什么情况不走索引
* 对索引的字段做函数操作,可能会破坏索引值的有序性因此优化器就决定放弃走树搜索的功能,需要注意的是,优化器并不是要放弃使用这个索引
* 隐式类型转换不走索引:比方说tradeid本来是varchar,结果写成了如下sql,没有带引号

    mysql> select * from tradelog where tradeid=110717;
* 不遵守最左前缀原则对复合索引的查询的操作

#### MySQL的delete和truncate的区别?
* delete是一条一条删除记录的,配合事件和回滚可以找回数据,并且自增不会重置
* truncate是直接删除整个表,然后创建一个一模一样的新表,auto_increment会被重置,且数据无法找回

#### 什么是幻读，脏读，不可重复读呢？
* 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读
* 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。
* 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。

#### 执行计划（explain）
#### select for update有什么含义，会锁表还是锁行还是其他。
* select for update 含义，select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。没用索引/主键的话就是表锁，否则就是是行锁。

####优化limit分页

		//方案一 ：返回上次查询的最大记录(偏移量)
		select id，name from employee where id>10000 limit 10.
		//方案二：order by + 索引
		select id，name from employee order by id  limit 10000，10
		//方案三：在业务允许的情况下限制页数：
#### 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。