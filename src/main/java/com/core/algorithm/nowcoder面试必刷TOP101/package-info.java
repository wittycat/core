package com.core.algorithm.nowcoder面试必刷TOP101;

/**
 * https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295
 * 
 * 1.Arrays: 排序，查找
 *   java.util.Arrays#sort(int[], int, int)
 *   java.util.Arrays#sort(long[])
 *   //必须在进行此调用之前对数组进行排序（通过 sort(int[]) 方法）。
 *   //如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。
 *   java.util.Arrays#binarySearch(int[], int)
 *
 * 2.数据结构
 *   数组
 *
 *   单链表：
 *      解题思路
 *          虚头
 *          提前记录当前节点（指针）
 *   双链表：
 *      Stack
 *      场景分析：
 *          2个栈，构建一个队列：一个放，一个取（没有了从另外一个放）
 *   队列
 *      //将元素插入队列尾部，方法在添加失败(比如队列已满)时，不会抛出异常，值会返回false
 *      boolean offer(E e);
 *      //将队首的元素删除，队列为空则返回null
 *      E poll();
 *      //获取队首元素，但不移除，队列为空则返回null
 *      E peek();
 *
 *      //将元素插入队列尾部，方法在添加失败(比如队列已满)时会报 一些运行时错误.
 *      boolean add(E e);
 *      //将队首的元素删除，队列为空则抛出异常
 *      E remove();
 *      //获取队首元素，但不移除，队列为空则抛出异常
 *      E element();
 *
 *   堆
 *      PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(); //⼩顶堆，默认容量为11
 *      PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(11,new Comparator<Integer>(){
 *            @Override
 *            public int compare(Integer i1,Integer i2){
 *                      return i2-i1;
 *                  }
 *            });//⼤顶堆
 *   哈希
 *   二叉树
 *      类别
 *          满二叉树（最标准，节点最多）
 *          完全二叉树（倒数第一层左到右连续，倒数第二层左到右连续）满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树
 *             堆总是一棵完全二叉树。
 *          线索二叉树
 *          二叉搜索树(BST二叉排序树) ：中序遍历后为一个，数组小到大
 *          平衡二叉树（AVL）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
 *      操作
 *          前序遍历：根左右
 *          中序遍历：左根右
 *          后续遍历：左右根
 *      场景分析：
 *          三种遍历：（深度遍历）
 *              前序遍历+中序遍历的数组:重构二叉树
 *          层级遍历：（广度遍历）
 *              解决深度；
 *              "之"形状打印
 *              序列化二叉树
 *          把整体二叉树看待成一个小二叉树，然后使用递归可以解决：
 *              合并2个二叉树;
 *              某个链路求和;
 *              二叉树的镜像;
 *              两个节点的最近公共祖先:
 *                  步骤：获取根到点的值路径。相同最后一个点为公共祖先
 *                  注意：ArrayList有时更优 LinkList
 *                       递归不要在局部创建集合（有返回值），从最外层传入（无返回值）
 *                       如果不使用结构不必要保存TreeNode，直接保存值TreeNode.val就行
 *
 *
 * 3.算法
 *    查找：
 *     链式查找法：链表或者数组一个个比较查找
 *     二分查找法：
 *          一维数组，获取 最小（l），最大角标（r）去取中间角标m值，大于r=m-1，否则l=m+1
 *          二维数组，取左下角值，大y移动（y--），小了x移动（x++），找不到不存在
 *     排序：
 *          归并排序，【BM20 数组中的逆序对】
 *
 *
 *
 * *********************************************************************************************************************************
 * 数据结构--最小生成树详解 普里姆算法—Prim算法 https://blog.csdn.net/qq_35644234/article/details/59106779
 * 最短路径问题---Floyd算法详解  https://blog.csdn.net/qq_35644234/article/details/60875818
 * *********************************************************************************************************************************
 * DFS 和 BFS 是非常重要的两种算法，大家一定要掌握，本文为了方便讲解，只对树做了 DFS，BFS，大家可以试试如果用图的话该怎么写代码，
 * 原理其实也是一样，只不过图和树两者的表示形式不同而已，DFS 一般是解决连通性问题，而 BFS 一般是解决最短路径问题。
 *    深度优先遍历该怎么实现呢，有递归和非递归两种表现形式
 *      实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。
 *    广度优先遍历也叫层序遍历
 *    
 * https://blog.csdn.net/qq_44918331/article/details/115542177?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165380807716782350983625%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165380807716782350983625&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115542177-null-null.142^v11^pc_search_result_control_group,157^v12^control&utm_term=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86&spm=1018.2226.3001.4187
 * *********************************************************************************************************************************
 * 排序
 *  比较和非比较的区别
 *  常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
 *  在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。
 *  比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
 *
 *   计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
 * 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。
 * 非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。
 * https://www.cnblogs.com/guoyaohua/p/8600214.html
 * *********************************************************************************************************************************
 * *********************************************************************************************************************************
 *
 *
 */

